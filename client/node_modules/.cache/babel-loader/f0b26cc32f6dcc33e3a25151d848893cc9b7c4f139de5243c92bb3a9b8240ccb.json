{"ast":null,"code":"import mqtt from 'precompiled-mqtt';\nconst SessionStatus = Object.freeze({\n  Joining: Symbol(\"joining\"),\n  // Getting session info and subscribing to MQTT topics\n  Waiting: Symbol(\"waiting\"),\n  // Waiting for the question to be defined and loaded\n  Active: Symbol(\"active\") // Answering the question, all users are interacting\n});\n\nclass Session {\n  constructor(sessionId, participantId, controlCallback, updateCallback) {\n    console.log(\"SESSION CONSTRUCTOR CALLED\");\n    this.sessionId = sessionId;\n    this.participantId = participantId;\n    this.client = mqtt.connect(`ws://${window.location.hostname}:9001/`, {\n      clean: true,\n      connectTimeout: 4000\n    });\n    this.client.on('connect', () => {\n      console.log('[MQTT] Client connected to broker');\n      //Se imprime el mensaje por consola en caso de que se haya subscrito correctamente\n      if (participantId === 0) {\n        this.client.subscribe([`swarm/session/${sessionId}/control/+`, `swarm/session/${sessionId}/updates/+`], err => {\n          if (!err) console.log(\"[MQTT] Subscribed to /swarm/session/#\");\n        });\n      } else {\n        this.client.subscribe([`swarm/session/${sessionId}/control`, `swarm/session/${sessionId}/updates/+`], err => {\n          if (!err) console.log(\"[MQTT] Subscribed to /swarm/session/#\");\n        });\n        this.publishControl({\n          type: 'join',\n          participant: participantId\n        });\n      }\n    });\n    this.client.on('message', (topic, message) => {\n      //Guardamos los datos del topic y los spliteamos en un array de strings\n      const topic_data = topic.split('/', 5);\n      //Comprobamos que los datos tengan el formato correcto\n      if (topic_data.length < 4 || topic_data[0] !== 'swarm' || topic_data[1] !== 'session'\n      //Para comprobar que la posicion 2 no sea vacía\n      || !topic_data[2].length\n      //Comprueba que sea un numero ya que esta es la posicion del id de la session\n      || isNaN(topic_data[2])) {\n        console.log(`[MQTT] Invalid topic '${topic}'`);\n        return;\n      }\n\n      // const sessionId = topic_data[2];\n      // if (sessionId !== this.sessionId) {\n      //     console.log(`[MQTT] Unknown session ID '${sessionId}'`);\n      //     return;\n      // }\n\n      if (topic_data[3] === 'control') {\n        if (participantId !== 0) controlCallback(JSON.parse(message));else if (sessionId === topic_data[2]) console.log(\"Mensaje de control\", message);\n        controlCallback(JSON.parse(message));\n      } else if (topic_data[3] === 'updates') {\n        if (topic_data.length !== 5) {\n          console.log('[MQTT] An update was received in a non-participant-specific topic');\n          return;\n        }\n        const participantId = topic_data[4];\n        if (participantId !== this.participantId) {\n          // Discard self updates\n          updateCallback(participantId, JSON.parse(message));\n        }\n      }\n    });\n  }\n  //Para que el cliente publique un mensaje de control en el que incluirá datos en formato JSON\n  publishControl(controlMessage) {\n    console.log(controlMessage);\n    this.client.publish(`swarm/session/${this.sessionId}/control/${this.participantId}`, JSON.stringify(controlMessage));\n  }\n  //Para que el cliente publique un mensaje de actualización en el que incluirá datos en formato JSON\n  //Típicamente estos datos harán referencia a la posición de la bolita de nuestro componenete BoardView\n  publishUpdate(updateMessage) {\n    this.client.publish(`swarm/session/${this.sessionId}/updates/${this.participantId}`, JSON.stringify(updateMessage));\n  }\n  //Para cerrar la conexión\n  close() {\n    this.client.end();\n  }\n}\nexport { SessionStatus, Session };","map":{"version":3,"names":["mqtt","SessionStatus","Object","freeze","Joining","Symbol","Waiting","Active","Session","constructor","sessionId","participantId","controlCallback","updateCallback","console","log","client","connect","window","location","hostname","clean","connectTimeout","on","subscribe","err","publishControl","type","participant","topic","message","topic_data","split","length","isNaN","JSON","parse","controlMessage","publish","stringify","publishUpdate","updateMessage","close","end"],"sources":["C:/VISILAB/Hans/HANS-Platform/client/src/context/Session.js"],"sourcesContent":["\r\nimport mqtt from 'precompiled-mqtt';\r\n\r\nconst SessionStatus = Object.freeze({\r\n    Joining: Symbol(\"joining\"), // Getting session info and subscribing to MQTT topics\r\n    Waiting: Symbol(\"waiting\"), // Waiting for the question to be defined and loaded\r\n    Active: Symbol(\"active\"),   // Answering the question, all users are interacting\r\n});\r\n\r\nclass Session {\r\n    constructor(sessionId, participantId, controlCallback, updateCallback) {\r\n        console.log(\"SESSION CONSTRUCTOR CALLED\");\r\n        this.sessionId = sessionId;\r\n        this.participantId = participantId;\r\n\r\n        this.client = mqtt.connect(\r\n            `ws://${window.location.hostname}:9001/`,\r\n            {\r\n                clean: true,\r\n                connectTimeout: 4000,\r\n            }\r\n        );\r\n        this.client.on('connect', () => {\r\n            console.log('[MQTT] Client connected to broker');\r\n            //Se imprime el mensaje por consola en caso de que se haya subscrito correctamente\r\n            if (participantId === 0) {\r\n                this.client.subscribe([\r\n                    `swarm/session/${sessionId}/control/+`,\r\n                    `swarm/session/${sessionId}/updates/+`,\r\n                ], (err) => {\r\n                    if (!err) console.log(\"[MQTT] Subscribed to /swarm/session/#\");\r\n                });\r\n            } else {\r\n                this.client.subscribe([\r\n                    `swarm/session/${sessionId}/control`,\r\n                    `swarm/session/${sessionId}/updates/+`,\r\n                ], (err) => {\r\n                    if (!err) console.log(\"[MQTT] Subscribed to /swarm/session/#\");\r\n                });\r\n                this.publishControl({ type: 'join', participant: participantId });\r\n            }\r\n\r\n        });\r\n        this.client.on('message', (topic, message) => {\r\n            //Guardamos los datos del topic y los spliteamos en un array de strings\r\n            const topic_data = topic.split('/', 5);\r\n            //Comprobamos que los datos tengan el formato correcto\r\n            if (\r\n                (topic_data.length < 4)\r\n                || (topic_data[0] !== 'swarm')\r\n                || (topic_data[1] !== 'session')\r\n                //Para comprobar que la posicion 2 no sea vacía\r\n                || !topic_data[2].length\r\n                //Comprueba que sea un numero ya que esta es la posicion del id de la session\r\n                || isNaN(topic_data[2])\r\n            ) {\r\n                console.log(`[MQTT] Invalid topic '${topic}'`);\r\n                return;\r\n            }\r\n\r\n            // const sessionId = topic_data[2];\r\n            // if (sessionId !== this.sessionId) {\r\n            //     console.log(`[MQTT] Unknown session ID '${sessionId}'`);\r\n            //     return;\r\n            // }\r\n\r\n            if (topic_data[3] === 'control') {\r\n                if (participantId !== 0)\r\n                    controlCallback(JSON.parse(message));\r\n                else if (sessionId === topic_data[2])\r\n                    console.log(\"Mensaje de control\", message);\r\n                    controlCallback(JSON.parse(message));\r\n            }\r\n            else if (topic_data[3] === 'updates') {\r\n                if (topic_data.length !== 5) {\r\n                    console.log('[MQTT] An update was received in a non-participant-specific topic');\r\n                    return;\r\n                }\r\n                const participantId = topic_data[4];\r\n                if (participantId !== this.participantId) {  // Discard self updates\r\n                    updateCallback(participantId, JSON.parse(message));\r\n                }\r\n            }\r\n        });\r\n    }\r\n    //Para que el cliente publique un mensaje de control en el que incluirá datos en formato JSON\r\n    publishControl(controlMessage) {\r\n        console.log(controlMessage);\r\n        this.client.publish(\r\n            `swarm/session/${this.sessionId}/control/${this.participantId}`,\r\n            JSON.stringify(controlMessage)\r\n        );\r\n    }\r\n    //Para que el cliente publique un mensaje de actualización en el que incluirá datos en formato JSON\r\n    //Típicamente estos datos harán referencia a la posición de la bolita de nuestro componenete BoardView\r\n    publishUpdate(updateMessage) {\r\n        this.client.publish(\r\n            `swarm/session/${this.sessionId}/updates/${this.participantId}`,\r\n            JSON.stringify(updateMessage)\r\n        );\r\n    }\r\n    //Para cerrar la conexión\r\n    close() {\r\n        this.client.end();\r\n    }\r\n}\r\n\r\nexport { SessionStatus, Session };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}